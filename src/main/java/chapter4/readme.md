## Stream API

当前 Java 集合操作存在的痛点：

1，很多业务逻辑都涉及类似于数据库的操作，比如对几道菜按照类别进行分组，或查找出最贵的菜。
自己用迭代器重新实现过这些操作多少遍？大部分数据库都允许你声明式地指定这些操作。
比如，以下 SQL 查询语句就可以选出热量较低的菜肴名称：SELECT name FROM dishes WHERE calorie < 400。
不需要实现如何根据菜肴的属性进行筛选（比如利用迭代器和累加器），只需要表达你想要什么。
这个基本的思路意味着，你用不着担心怎么去显式地实现这些查询语句——都替你办好了！怎么到了集合这里就不能这样了呢？

2，要处理大量元素又该怎么办呢？为了提高性能，你需要并行处理，并利用多核架构。但写并行代码比用迭代器还要复杂，而且调试起来也够受的！

流是 Java API 的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。
就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，流还可以透明地并行处理，你无需写任何多线程代码了！

### 流简介

流到底是什么呢？简短的定义就是“从支持数据处理操作的源生成的元素序列”。

* 元素序列

    就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素。
    但流的目的在于表达计算，比如 filter、sorted 和 map。集合讲的是数据，流讲的是计算。
* 源

    流会使用一个提供数据的源，如集合、数组或输入/输出资源。从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。
* 数据处理操作

    流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如 filter、map、reduce、find、match、sort 等。
    流操作可以顺序执行，也可并行执行。

流操作有两个重要的特点。

* 流水线

    很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。流水线的操作可以看作对数据源进行数据库式查询。

* 内部迭代

    与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。


### 集合与流

集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。
你可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分。

相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。流就像是一个延迟创建的集合：只有在消费者要求的时候才会计算值。

和迭代器类似，流只能遍历一次。遍历完之后，我们就说这个流已经被消费掉了。
你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集合之类的可重复的源，如果是 I/O 通道就没戏了）。

集合和流的另一个关键区别在于它们遍历数据的方式。使用 Collection 接口需要用户去做迭代（比如用for-each），这称为外部迭代。
相反，Streams 库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。
